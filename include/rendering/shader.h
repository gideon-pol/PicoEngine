#pragma once

#include "rendering/color.h"
#include "rendering/mesh.h"
#include "rendering/texture.h"

struct TriangleShaderData {
    Vertex v1;
    Vertex v2;
    Vertex v3;
    // This value is not set, but it can be generated by the vertex program
    // It is used to interpolate the triangle color and therefore does not
    // need the invocation of a program for every pixel.
    Color TriangleColor;
};

struct FragmentShaderData {
    // This is for now a face normal
    vec3f Normal;
    vec3f FragCoord;
    vec2f UV;
    vec2i16 ScreenSize;
    Color FragmentColor;
};

enum ShaderType { WireFrame, Flat, Texture, Custom };

class Shader {
public:
    ShaderType Type;
    // The triangle program runs for every triangle, regardless of visibility!
    void (*TriangleProgram)(TriangleShaderData& input, void* parameters);
    void (*FragmentProgram)(FragmentShaderData& input, void* parameters);

    virtual void* CreateParameters(){
        return nullptr;
    }
};

class FlatShader : public Shader {
public:
    typedef struct {
        Color _Color;
    } Parameters;

    FlatShader(){
        // TODO: Test whether this is (significantly) slower than an engine implemented shader
        Type = ShaderType::Custom;
        // TriangleProgram = [](TriangleShaderData& i, void* p){
        //     i.TriangleColor = ((Parameters*)p)->_Color;
        // };
        Type = ShaderType::Flat;
        TriangleProgram = nullptr;
        FragmentProgram = nullptr;
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

// TODO: this shader is probably so common that it should be engine implemented
class LightingShader : public Shader {
public:
    enum ShadingType { Flat, Smooth };

    typedef struct {
        vec3f LightDirection;
        Color LightColor;
        Color AmbientColor;
        mat4f* ModelMatrix;
    } Parameters;

    LightingShader(ShadingType type){
        Type = ShaderType::Custom;
        TriangleProgram = nullptr;

        if(type == ShadingType::Flat){
            FragmentProgram = nullptr;
            TriangleProgram = [](TriangleShaderData& data, void* parameters){
                Parameters* params = (Parameters*)parameters;
                vec3f normal = (data.v2.Position - data.v1.Position).cross(data.v3.Position - data.v1.Position).normalize();
                normal = (*params->ModelMatrix * vec4f(normal, 0)).xyz().normalize();
                float diff = normal.dot(-params->LightDirection) * 0.5f + 0.5f;
                data.TriangleColor = Color(
                                        static_cast<uint8_t>(params->LightColor.r * diff),
                                        static_cast<uint8_t>(params->LightColor.g * diff),
                                        static_cast<uint8_t>(params->LightColor.b * diff),
                                        255
                                    );
            };
        } else if(type == ShadingType::Smooth){
            TriangleProgram = nullptr;
            FragmentProgram = [](FragmentShaderData& data, void* parameters){
                Parameters* params = (Parameters*)parameters;
                float diff = data.Normal.dot(-params->LightDirection) * 0.5f + 0.5f;
                data.FragmentColor = Color(
                                        static_cast<uint8_t>(params->LightColor.r * diff),
                                        static_cast<uint8_t>(params->LightColor.g * diff),
                                        static_cast<uint8_t>(params->LightColor.b * diff),
                                        255
                                    );
            };
        } 
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

// The wireframe shader is engine-implemented.
// This class is really only for the parameters object
class WireFrameShader : public Shader {
public:
    struct Parameters {
        Color _Color;
    };

    WireFrameShader(){
        Type = ShaderType::WireFrame;
        TriangleProgram = nullptr;
        FragmentProgram = nullptr;
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

class RainbowTestShader : public Shader {
public:
    RainbowTestShader(){
        Type = ShaderType::Custom;
        TriangleProgram = nullptr;

        FragmentProgram = [](FragmentShaderData& data, void* parameters){
            vec2f uv = data.FragCoord.xy() / vec2f(data.ScreenSize);
            float h = uv(0) * 360;
            data.FragmentColor = Color::FromHSV(h, 1, 1);
        };
    }

    void* CreateParameters(){
        return nullptr;
    }
};

class TextureShader : public Shader {
public:
    struct Parameters {
        Texture2D* _Texture;
        vec2f TextureScale;
    };

    TextureShader(){
        Type = ShaderType::Texture;
        TriangleProgram = nullptr;
        // Engine implemented version is 20% to 30% faster 
        FragmentProgram = nullptr;
        // FragmentProgram = [](FragmentShaderData& data, void* parameters){
        //     Parameters* params = (Parameters*)parameters;
        //     data.FragmentColor = params->_Texture->Sample(data.UV);
        // };
    }

    void* CreateParameters(){
        return new Parameters();
    }
};


struct Material {
    Shader& _Shader;
    void* Parameters;

    Material(Shader& shader) : _Shader(shader){
        Parameters = _Shader.CreateParameters();
    }
};