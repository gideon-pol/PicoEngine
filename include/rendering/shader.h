#pragma once

#include "rendering/color.h"
#include "rendering/mesh.h"

struct TriangleShaderData {
    Vertex v1;
    Vertex v2;
    Vertex v3;
    // This value is not set, but it can be generated by the vertex program
    // It is used to interpolate the triangle color and therefore does not
    // need the invocation of a program for every pixel.
    Color TriangleColor;
};

struct FragmentShaderData {
    // This is for now a face normal
    vec3f Normal;
    vec3f FragCoord;
    vec2f UV;
    vec2i16 ScreenSize;
    Color FragmentColor;
};

enum ShaderType { WireFrame, Flat, Texture, Custom };

class Shader {
public:
    ShaderType Type;
    // The triangle program runs for every triangle, regardless of visibility!
    void (*TriangleProgram)(TriangleShaderData& input, void* parameters);
    void (*FragmentProgram)(FragmentShaderData& input, void* parameters);

    virtual void* CreateParameters(){
        return nullptr;
    }
};

class FlatShader : public Shader {
public:
    typedef struct {
        Color _Color;
    } Parameters;

    FlatShader(){
        // TODO: Test whether this is (significantly) slower than an engine implemented shader
        Type = ShaderType::Custom;
        // TriangleProgram = [](TriangleShaderData& i, void* p){
        //     i.TriangleColor = ((Parameters*)p)->_Color;
        // };
        Type = ShaderType::Flat;
        TriangleProgram = nullptr;
        FragmentProgram = nullptr;
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

// TODO: this shader is probably so common that it should be engine implemented
class LightingShader : public Shader {
public:
    typedef struct {
        vec3f LightPosition;
        Color LightColor;
        Color AmbientColor;
    } Parameters;

    LightingShader(){
        Type = ShaderType::Custom;
        TriangleProgram = [](TriangleShaderData& data, void* parameters){
            Parameters* params = (Parameters*)parameters;
            vec3f lightDir = -params->LightPosition.normalize();
            vec3f normal = (data.v2.Position - data.v1.Position).cross(data.v3.Position - data.v1.Position).normalize();
            float diff = normal.dot(lightDir) * 0.5f + 0.5f;
            data.TriangleColor = Color(
                                    static_cast<uint8_t>(params->LightColor.r * diff),
                                    static_cast<uint8_t>(params->LightColor.g * diff),
                                    static_cast<uint8_t>(params->LightColor.b * diff),
                                    255
                                );
        };

        FragmentProgram = nullptr;
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

// The wireframe shader is engine-implemented.
// This class is really only for the parameters object
class WireFrameShader : public Shader {
public:
    struct Parameters {
        Color _Color;
    };

    WireFrameShader(){
        Type = ShaderType::WireFrame;
        TriangleProgram = nullptr;
        FragmentProgram = nullptr;
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

class RainbowTestShader : public Shader {
public:
    RainbowTestShader(){
        Type = ShaderType::Custom;
        TriangleProgram = nullptr;

        FragmentProgram = [](FragmentShaderData& data, void* parameters){
            vec2f uv = data.FragCoord.xy() / vec2f(data.ScreenSize);
            float h = uv(0) * 360;
            data.FragmentColor = Color::FromHSV(h, 1, 1);
        };
    }

    void* CreateParameters(){
        return nullptr;
    }
};

struct Material {
    Shader& _Shader;
    void* Parameters;

    Material(Shader& shader) : _Shader(shader){
        Parameters = _Shader.CreateParameters();
    }
};