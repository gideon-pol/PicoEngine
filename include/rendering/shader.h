#pragma once

#include "rendering/color.h"
#include "rendering/mesh.h"
#include "rendering/texture.h"

#define SHADER_AUTO_ID(class, ...) \
    inline static const uint64_t ID = __COUNTER__; \
    class(Shader& shader) : Shader(ID) { } \
    class(__VA_ARGS__) : Shader(ID)

#define SHADER_PARAMS(class, obj) \
    ((class::Parameters*)obj->Parameters)

struct TriangleShaderData {
    const mat4f& ModelMatrix;
    const Vertex v1;
    const Vertex v2;
    const Vertex v3;
    // This value is not set, but it can be generated by the vertex program
    // It is used to interpolate the triangle color and therefore does not
    // need the invocation of a program for every pixel.
    Color TriangleColor;
};

struct FragmentShaderData {
    const Vertex& V1, V2, V3;
    const mat4f& ModelMatrix;
    const vec3f UVW;
    const vec3f FragCoord;
    const vec2i16 ScreenSize;
    Color FragmentColor;
};

class Shader {
public:
    inline static const uint64_t ID = -1;
    const uint64_t _ID = -1;

    Shader(uint64_t id = -1) : _ID(id) {}
    
    // The triangle program runs for every triangle, regardless of visibility!
    inline void TriangleProgram(TriangleShaderData& input, void* parameters){
        
    }

    inline void FragmentProgram(FragmentShaderData& input, void* parameters){
        
    }

    virtual void* CreateParameters(){
        return nullptr;
    }
};

class FlatShader : public Shader {
public:
    struct Parameters {
        Color _Color;
    };

    SHADER_AUTO_ID(FlatShader){
    }

    inline void TriangleProgram(TriangleShaderData& data, void* parameters){
        Parameters* params = (Parameters*)parameters;
        data.TriangleColor = params->_Color;
    }

    void* CreateParameters(){
        return new Parameters();
    }
};
class FlatLightingShader : public Shader {
public:
    struct Parameters {
        vec3f LightDirection;
        Color LightColor;
        Color AmbientColor;
    };

    SHADER_AUTO_ID(FlatLightingShader){
    }

    inline void TriangleProgram(TriangleShaderData& data, void* parameters){
        Parameters* params = (Parameters*)parameters;
        vec3f normal = (data.v2.Position - data.v1.Position).cross(data.v3.Position - data.v1.Position).normalize();
        normal = (data.ModelMatrix * vec4f(normal, 0)).xyz().normalize();
        fixed diff = max(normal.dot(-params->LightDirection), 0fp);
        data.TriangleColor = Color(
                                SCAST<uint8_t>(fixed(params->LightColor.r) * diff),
                                SCAST<uint8_t>(fixed(params->LightColor.g) * diff),
                                SCAST<uint8_t>(fixed(params->LightColor.b) * diff),
                                255
                            );
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

class SmoothLightingShader : public Shader {
public:
    struct Parameters {
        vec3f LightDirection;
        Color LightColor;
        Color AmbientColor;
    };

    SHADER_AUTO_ID(SmoothLightingShader){
    }

    inline void FragmentProgram(FragmentShaderData& data, void* parameters){
        Parameters* params = (Parameters*)parameters;
        vec3f normal = (data.V1.Normal * data.UVW(0) + data.V2.Normal * data.UVW(1) + data.V3.Normal * data.UVW(2)).normalize();
        fixed diff = max(normal.dot(-params->LightDirection), 0fp);
        data.FragmentColor = Color(
                                SCAST<uint8_t>(fixed(params->LightColor.r) * diff),
                                SCAST<uint8_t>(fixed(params->LightColor.g) * diff),
                                SCAST<uint8_t>(fixed(params->LightColor.b) * diff),
                                255
                            );
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

class RainbowTestShader : public Shader {
public:
    SHADER_AUTO_ID(RainbowTestShader){
    }

    inline void FragmentProgram(FragmentShaderData& data, void* parameters){
        vec2f uv = data.FragCoord.xy() / vec2f(data.ScreenSize);
        fixed h = uv(0) * 360fp;
        data.FragmentColor = Color::FromHSV((float)h, 1, 1);
    }

    void* CreateParameters(){
        return nullptr;
    }
};

class TextureShader : public Shader {
public:
    struct Parameters {
        Texture2D* _Texture;
        vec2f TextureScale;
    };

    SHADER_AUTO_ID(TextureShader){
    }

    inline void FragmentProgram(FragmentShaderData& data, void* parameters){
        TextureShader::Parameters* params = (TextureShader::Parameters*)parameters; \
        Texture2D* tex = params->_Texture;
        vec2f uv = (data.V1.UV * data.UVW(0) + data.V2.UV * data.UVW(1) + data.V3.UV * data.UVW(2)); \
        uv = vec2f(uv.x() * params->TextureScale.x(), uv.y() * params->TextureScale.y()); \
        data.FragmentColor = tex->Sample(uv);
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

struct Material {
    Shader& _Shader;
    void* Parameters;

    Material(Shader& shader) : _Shader(shader){
        Parameters = _Shader.CreateParameters();
    }
};


#define END(...) END_(__VA_ARGS__)
#define END_(...) __VA_ARGS__##_END

#define LOOP_FRAGMENT(seq) END(A_FRAGMENT seq)
#define BODY_FRAGMENT(x) case x::ID: \
        ((x)shader).FragmentProgram(data, parameters); \
        break;
#define A_FRAGMENT(x) BODY_FRAGMENT(x) B_FRAGMENT
#define B_FRAGMENT(x) BODY_FRAGMENT(x) A_FRAGMENT
#define A_FRAGMENT_END
#define B_FRAGMENT_END

#define LOOP_TRIANGLE(seq) END(A_TRIANGLE seq)
#define BODY_TRIANGLE(x) case x::ID: \
        ((x)shader).TriangleProgram(data, parameters); \
        break;
#define A_TRIANGLE(x) BODY_TRIANGLE(x) B_TRIANGLE
#define B_TRIANGLE(x) BODY_TRIANGLE(x) A_TRIANGLE
#define A_TRIANGLE_END
#define B_TRIANGLE_END

#define REGISTER_SHADERS(shaders) \
FORCE_INLINE void executeTriangleProgram(Shader& shader, TriangleShaderData& data, void* parameters){ \
    switch(shader._ID){ \
        LOOP_TRIANGLE(shaders) \
        default: \
            break; \
    } \
} \
\
FORCE_INLINE void executeFragmentProgram(Shader& shader, FragmentShaderData& data, void* parameters){ \
    switch(shader._ID){ \
        LOOP_FRAGMENT(shaders) \
        default: \
            break; \
    } \
}

extern FORCE_INLINE void executeTriangleProgram(Shader& shader, TriangleShaderData& data, void* parameters);
extern FORCE_INLINE void executeFragmentProgram(Shader& shader, FragmentShaderData& data, void* parameters);

