#pragma once

#include "rendering/color.h"
#include "rendering/mesh.h"

struct TriangleShaderData {
    Vertex v1;
    Vertex v2;
    Vertex v3;
    // This value is not set, but it can be generated by the vertex program
    // It is used to interpolate the triangle color and therefore does not
    // need the invocation of a program for every pixel.
    Color TriangleColor;
};

struct FragmentShaderData {
    // This is for now a face normal
    vec3f Normal;
    vec2f UV;
    Color FragmentColor;
};

enum ShaderType { WireFrame, Flat, Texture, Custom };

class Shader {
public:
    ShaderType Type;
    void (*TriangleProgram)(TriangleShaderData& input, void* parameters);
    void (*FragmentProgram)(FragmentShaderData& input, void* parameters);

    virtual void* CreateParameters(){
        return nullptr;
    }
};

class FlatShader : public Shader {
public:
    typedef struct {
        Color _Color;
    } Parameters;

    FlatShader(){
        // TODO: Test whether this is (significantly) slower than an engine implemented shader
        Type = ShaderType::Custom;
        TriangleProgram = [](TriangleShaderData& i, void* p){
            i.TriangleColor = ((Parameters*)p)->_Color;
        };
        // Type = ShaderType::Flat;
        // TriangleProgram = nullptr;
        FragmentProgram = nullptr;
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

class LightingShader : public Shader {
public:
    typedef struct {
        vec3f LightPosition;
        Color LightColor;
        Color AmbientColor;
    } Parameters;

    LightingShader(){
        Type = ShaderType::Custom;
        TriangleProgram = nullptr;

        FragmentProgram = [](FragmentShaderData& input, void* parameters){
            Parameters* params = (Parameters*)parameters;
            vec3f lightDir = -params->LightPosition.normalize();
            float diff = input.Normal.dot(lightDir);
            Color diffuse = Color(
                                static_cast<uint8_t>(params->LightColor.r * diff),
                                static_cast<uint8_t>(params->LightColor.g * diff),
                                static_cast<uint8_t>(params->LightColor.b * diff),
                                255
                            );
            input.FragmentColor = diffuse;
        };
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

// The wireframe shader is engine-implemented.
// This class is really only for the parameters object
class WireFrameShader : public Shader {
public:
    struct Parameters {
        Color _Color;
    };

    WireFrameShader(){
        Type = ShaderType::WireFrame;
        TriangleProgram = nullptr;
        FragmentProgram = nullptr;
    }

    void* CreateParameters(){
        return new Parameters();
    }
};

struct Material {
    Shader& _Shader;
    void* Parameters;

    Material(Shader& shader) : _Shader(shader){
        Parameters = _Shader.CreateParameters();
    }
};